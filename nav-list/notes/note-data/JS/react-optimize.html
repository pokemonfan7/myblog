<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport"
	      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Alexz的博客网站</title>
	<link rel="stylesheet" href="./style.css">
</head>
<body>
<nav class="navbar-fixed-top">
	<div class="container">
		<div class="fl">
			<a class="logo" href="../../../../index.html"></a>
		</div>
		<ul class="nav-left fl">
			<li class="fl"><a href="../../../../index.html">首页</a></li>
			<li class="fl"><a href="../../../works/works.html">我的作品</a></li>
			<li class="fl"><a href="../../../notes/notes.html">我的笔记</a></li>
			<li class="fl"><a class="new" href="../../../demos/demos.html">我的demo</a></li>
		</ul>
		<ul class="nav-right fr">
			<li class="fl"><a id="backToTop"></a></li>
			<li class="fl"><a class="login" href="">登录</a></li>
			<li class="fl"><a class="register" href="">注册</a></li>
		</ul>
	</div>
</nav>
<main>
	<article class="fl">
		<div class="article-head">
			<h1>react优化</h1>
		</div>
		<div class="article-body">
			<p>不在render方法中绑定this或用箭头函数执行，因为每次render执行时，会再次执行一遍</p>
			<pre>onClick={this.handleClick.bind(this)}
onClick={()=>{this.handleClick()}}
</pre>
			<p>当父组件render时，子组件也会render，如果子组件render前后并没有改变，那么可以用shouldComponentUpdate来定制优化，例如：</p>
			<pre>shouldComponentUpdate(nextProps,nextState){
	if(nextProps.title===this.props.title){	//title没有改变
	return faulse;
}
return true;
}
</pre>
			<p>若没有state，子组件可以直接extends React.PureComponent，这种方式更佳，但只是浅层比较，如果props和state发生突变，子组件也不会render。</p>
			<p>可以用immutable.js，便于数据比较，定制shouldComponentUpdate方便</p>
		</div>
	</article>
	<aside class="fr">
		<div class="aside-head">目录</div>
		<div class="aside-body">
		</div>
	</aside>
</main>
<script src="./index.js"></script>
</body>
</html>